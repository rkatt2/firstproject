SQL NOTES
=========

SQL Session 1:

==============================================

What is a database ?

A collection of data and holds this data in form of tables.

What is table ?

A entity Holds data in form of rows and columns.

it is similar to excel spreadsheet.

The database provide us the capability to access and manipulate the data.


2 types of databases
================================================

1) Relational Database:

Rows and columns and also the tables have relation between them.

Ex: Mysql, SQL Server, Postgres, SQL Lite, Maria DB and others

2) NOSQL database:

Key value, Document, Graph.

Ex: Hbase, MongoDB, Casandra and others.



SQL : Structured Query Language and is used to query relational databases.

Installation:

goormIDE:  mysql-ctl cli;

To list databases:
================================
show databases;

Create database:
=================================

CREATE DATABASE trendytech;

Drop database:

=================================

drop database trendytech;


How do I know which database I am in currently:

================================================

SELECT database();

Creating Table:

=======================================

CREATE TABLE employee
(
name VARCHAR(50),
age INT,
salary INT
) ;


To List tables:

===============================

show tables;

Structure of Table:


=====================================

describe table name;

desc tablename;

Drop Table:

======================================

drop table table name;


=========================================================================================================================================

Learn the SQL right way Session 2:
==============================================

CRUD Operations

create  --- Insert statements
read    --- select statements
update  ---  update statements
delete  ---- delete statements

Creation of Table and Insert statements:

=========================================

employee table

prefer to hire from bangalore location



CREATE TABLE employee (
firstname varchar(20),
middlename varchar(20),
lastname varchar(20),
age INT,
salary INT,
location varchar(20)
)

describe employee;

we are doing something with definition is called DDL

show tables;

select * from employee;

inserting data into Table:
=============================

INSERT INTO employee(firstname, middlename, lastname, age, salary, location) VALUES ('satya','nara','yana',36,60000,'bangalore');


INSERT INTO employee(firstname, middlename, lastname, age, salary, location) VALUES ('dhruvan','kumar','bhima',17,80000,'bangalore');

How to insert data into only few columns:
===============================================


INSERT INTO employee(firstname,  lastname, age, salary, location) VALUES ('Rajesh','sharma',28,10000,'bangalore');

INSERT INTO employee(firstname,  lastname, age, salary, location) VALUES ("Ritesh's",'sharma',28,10000,'bangalore');

INSERT INTO employee(firstname,  lastname, age, salary, location) VALUES ('Ritesh\'s','sharma',28,10000,'bangalore');


How to insert multiple values in one Go:

=============================================================================

INSERT INTO employee(firstname, middlename, lastname, age, salary, location) VALUES ('Kapil','Kumar','Sinha',28,10000,'bangalore'),('Satish','Kumar','Sinha',30,20000,'bangalore');

Datatype Mismatch:
======================================

INSERT INTO employee(firstname, middlename, lastname, age, salary, location) VALUES ('Kapildddddddddddddddddddddddjjjjjjjj','Kumar','Sinha',28,10000,'bangalore');

ERROR 1406 (22001): Data too long for column 'firstname' at row 1

NULL
=====================================


INSERT INTO employee(firstname, lastname, age, salary) VALUES ('Kumar','Sinha',29,10000);

Creating Table without NULL:

====================================

CREATE TABLE employee (
firstname varchar(20) NOT NULL,
middlename varchar(20),
lastname varchar(20) NOT NULL,
age INT NOT NULL,
salary INT NOT NULL,
location varchar(20) NOT NULL
);

INSERT INTO employee(middlename, lastname, age, salary, location) VALUES ('Kumar','Sinha',29,10000,'ba
ngalore');
ERROR 1364 (HY000): Field 'firstname' doesn't have a default value.

Default Values:

==================================

CREATE TABLE employee (
firstname varchar(20) NOT NULL,
middlename varchar(20),
lastname varchar(20) NOT NULL,
age INT NOT NULL,
salary INT NOT NULL,
location varchar(20) DEFAULT 'BANGLORE'
);


INSERT INTO employee(firstname, lastname, age, salary, location) VALUES ('satish','kumar',29,10000,'hyderabad');


INSERT INTO employee(firstname, lastname, age, salary, location) VALUES ('rajesh','kumar',29,10000,null);



Combination of NOT NOT and DEFAULT

=========================================
CREATE TABLE employee (
firstname varchar(20) NOT NULL,
middlename varchar(20),
lastname varchar(20) NOT NULL,
age INT NOT NULL,
salary INT NOT NULL,
location varchar(20) NOT NULL DEFAULT 'BANGLORE'
);

 INSERT INTO employee(firstname, lastname, age, salary) VALUES ('rajesh','kumar',29,10000);
l);
ERROR 1048 (23000): Column 'location' cannot be null

INSERT INTO employee(firstname, lastname, age, salary) VALUES ('rajesh','kumar',29,10000);


=========================================================================================================================================

Session 3: Primary Key Vs Unique Key
=========================================




Primaty Key,

Auto Increment Keys

Unique Key

Primary key vs unique key

INSERT INTO employee(firstname, lastname, age, salary) VALUES ('rajesh','kumar',29,10000);


Primary Key 
==============================
It helps us to uniquely identify in the table.


CREATE TABLE employee (
id INT,
firstname varchar(20) NOT NULL,
middlename varchar(20),
lastname varchar(20) NOT NULL,
age INT NOT NULL,
salary INT NOT NULL,
location varchar(20) NOT NULL DEFAULT 'BANGLORE'
);

INSERT INTO employee(id,firstname, lastname, age, salary) VALUES (1,'rajesh','kumar',29,10000),(2,'satish','kumar',28,30000);

Creating table with Primary Key:
===================================

CREATE TABLE employee (
id INT PRIMARY KEY,
firstname varchar(20) NOT NULL,
middlename varchar(20),
lastname varchar(20) NOT NULL,
age INT NOT NULL,
salary INT NOT NULL,
location varchar(20) NOT NULL DEFAULT 'BANGLORE'
);

INSERT INTO employee(id,firstname, lastname, age, salary) VALUES (3,'maneesh','kumar',30,10000)

For a primary key null values are not allowed and repeated values also not allowed.

INSERT INTO employee(id,firstname, lastname, age, salary) VALUES (NULL,'rejina','kumar',29,10000);
ERROR 1048 (23000): Column 'id' cannot be null

INSERT INTO employee(id,firstname, lastname, age, salary) VALUES (1,'rejina','kumar',29,10000);


INSERT INTO employee(id,firstname, lastname, age, salary) VALUES (1,'rejina','kumar',29,10000);
ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'

other way to define the primary key:

=====================================
CREATE TABLE employee (
id INT,
firstname varchar(20) NOT NULL,
middlename varchar(20),
lastname varchar(20) NOT NULL,
age INT NOT NULL,
salary INT NOT NULL,
location varchar(20) NOT NULL DEFAULT 'BANGLORE',
PRIMARY KEY(id)
);



Composite Primary Key:

CREATE TABLE employee (
id INT,
firstname varchar(20) NOT NULL,
middlename varchar(20),
lastname varchar(20) NOT NULL,
age INT NOT NULL,
salary INT NOT NULL,
location varchar(20) NOT NULL DEFAULT 'BANGLORE',
PRIMARY KEY(id,firstname)
);


creating Table with Autoincrement:

======================================


CREATE TABLE employee (
id INT AUTO_INCREMENT,
firstname varchar(20) NOT NULL,
middlename varchar(20),
lastname varchar(20) NOT NULL,
age INT NOT NULL,
salary INT NOT NULL,
location varchar(20) NOT NULL DEFAULT 'BANGLORE',
PRIMARY KEY(id)
);




INSERT INTO employee(firstname, lastname, age, salary) VALUES ('rejina','kumar',29,10000),('satish','ku
mar',29,10000),('brijexh','kumar',29,10000);
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> select * from employee;
+----+-----------+------------+----------+-----+--------+----------+
| id | firstname | middlename | lastname | age | salary | location |
+----+-----------+------------+----------+-----+--------+----------+
|  1 | rejina    | NULL       | kumar    |  29 |  10000 | BANGLORE |
|  2 | satish    | NULL       | kumar    |  29 |  10000 | BANGLORE |
|  3 | brijexh   | NULL       | kumar    |  29 |  10000 | BANGLORE |
+----+-----------+------------+----------+-----+--------+----------+


Unique Key:

===========================================



You can have only one primary key and primary key can not hold any null value.

We shopuld use primary key when we have to identify each record.


Unique key can hold NULL values

In MYSQL Unique key can hold any number of NULL values, 

in some of other famous DB's only it allow only NULL.

The purpose of unique key is to make sure the values do not duplicate.

You can have only one primary key but multiple unique keys in table.



CREATE TABLE employee (
firstname varchar(20) NOT NULL,
lastname varchar(20) NOT NULL,
age INT NOT NULL,
PRIMARY KEY(firstname,lastname)
);


insert into employee values ('kapil', 'sharma', 28);

insert into employee values ('kapil', 'sinha', 28);


CREATE TABLE employee (
id INT UNIQUE KEY,
firstname varchar(20) ,
lastname varchar(20) ,
age INT
);

=========================================================================================================================================

SQL SESSION 4:
======================================


Primary Key

Uniue Key

Auto  increment

CRUD Operations:

Create    Insert

Read      Select 

Update    Update

Delete    Delete


CREATE TABLE employee (
id INT,
firstname varchar(20) NOT NULL,
middlename varchar(20),
lastname varchar(20) NOT NULL,
age INT NOT NULL,
salary INT NOT NULL,
location varchar(20) NOT NULL DEFAULT 'BANGLORE',
PRIMARY KEY(id)
);


Select
===================

1)  selecting all columns:

select * from employee;

2) Selecting specific columns.

 select firstname,lastname from employee;
+-----------+----------+
| firstname | lastname |
+-----------+----------+
| rajesh    | kumar    |
| satish    | kumar    |
| rajesh    | kumar    |
+-----------+----------+

3) How to see list whose age is greater than 25;

Select by applying where clause.

select * from employee where age > 25;
+----+-----------+------------+----------+-----+--------+----------+
| id | firstname | middlename | lastname | age | salary | location |
+----+-----------+------------+----------+-----+--------+----------+
|  1 | rajesh    | NULL       | kumar    |  29 |  10000 | BANGLORE |
|  2 | satish    | NULL       | kumar    |  28 |  30000 | BANGLORE |
|  3 | rajesh    | NULL       | kumar    |  29 |  10000 | BANGLORE |
+----+-----------+------------+----------+-----+--------+----------+

4) Binary for case 

By default it is case insensitive.

select * from employee where binary firstname ='Rajesh';

This stmt match exact case for case sensitive.

Empty set (0.00 sec)

mysql> select * from employee where firstname ='Rajesh';
+----+-----------+------------+----------+-----+--------+----------+
| id | firstname | middlename | lastname | age | salary | location |
+----+-----------+------------+----------+-----+--------+----------+
|  1 | rajesh    | NULL       | kumar    |  29 |  10000 | BANGLORE |


5) 

 Alias: Use As Keyword.

select firstname as name,lastname as surname from employee;
+--------+---------+
| name   | surname |
+--------+---------+
| rajesh | kumar   |
| satish | kumar   |
| rajesh | kumar   |
+--------+---------+

Update:
================================


update employee set lastname = 'sharma' where firstname = 'maneesh';
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from employee;
+----+-----------+------------+----------+-----+--------+----------+
| id | firstname | middlename | lastname | age | salary | location |
+----+-----------+------------+----------+-----+--------+----------+
|  1 | rajesh    | NULL       | kumar    |  29 |  10000 | BANGLORE |
|  2 | satish    | NULL       | kumar    |  28 |  30000 | BANGLORE |
|  3 | maneesh   | NULL       | sharma   |  30 |  10000 | BANGLORE |
+----+-----------+------------+----------+-----+--------+----------+
 
 
update employee set location = 'hyderabad' where firstname = 'satish';
Query OK, 0 rows affected (0.01 sec)
Rows matched: 1  Changed: 0  Warnings: 0

mysql> select * from employee;
+----+-----------+------------+----------+-----+--------+-----------+
| id | firstname | middlename | lastname | age | salary | location  |
+----+-----------+------------+----------+-----+--------+-----------+
|  1 | rajesh    | NULL       | kumar    |  29 |  10000 | BANGLORE  |
|  2 | satish    | NULL       | kumar    |  28 |  30000 | hyderabad |
|  3 | maneesh   | NULL       | sharma   |  30 |  10000 | BANGLORE  |
+----+-----------+------------+----------+-----+--------+-----------+


update employee set salary=salary+5000;
Query OK, 3 rows affected (0.01 sec)
Rows matched: 3  Changed: 3  Warnings: 0

mysql> select * from employee;
+----+-----------+------------+----------+-----+--------+-----------+
| id | firstname | middlename | lastname | age | salary | location  |
+----+-----------+------------+----------+-----+--------+-----------+
|  1 | rajesh    | NULL       | kumar    |  29 |  15000 | BANGLORE  |
|  2 | satish    | NULL       | kumar    |  28 |  35000 | hyderabad |
|  3 | maneesh   | NULL       | sharma   |  30 |  15000 | BANGLORE  |
+----+-----------+------------+----------+-----+--------+-----------+

update employee set location = 'banglore' where firstname ='satish' and lastname = 'kumar';
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from employee;
+----+-----------+------------+----------+-----+--------+----------+
| id | firstname | middlename | lastname | age | salary | location |
+----+-----------+------------+----------+-----+--------+----------+
|  1 | rajesh    | NULL       | kumar    |  29 |  15000 | BANGLORE |
|  2 | satish    | NULL       | kumar    |  28 |  35000 | banglore |
|  3 | maneesh   | NULL       | sharma   |  30 |  15000 | BANGLORE |
+----+-----------+------------+----------+-----+--------+----------+


DELETE:
=========================================

DELETE from employee where id = 3;
Query OK, 1 row affected (0.02 sec)

mysql> select * from employee;
+----+-----------+------------+----------+-----+--------+----------+
| id | firstname | middlename | lastname | age | salary | location |
+----+-----------+------------+----------+-----+--------+----------+
|  1 | rajesh    | NULL       | kumar    |  29 |  15000 | BANGLORE |
|  2 | satish    | NULL       | kumar    |  28 |  35000 | banglore |
+----+-----------+------------+----------+-----+--------+----------+

delete from employee;
Query OK, 2 rows affected (0.08 sec)

mysql> select * from employee;
Empty set (0.00 sec)


ALTER:

================================


Alter is to alter the structure of the table.

alter table employee add column jobtitle varchar(50);


alter table employee add column jobtitle varchar(50);


Query OK, 0 rows affected (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC employee;
+------------+-------------+------+-----+----------+-------+
| Field      | Type        | Null | Key | Default  | Extra |
+------------+-------------+------+-----+----------+-------+
| id         | int(11)     | NO   | PRI | NULL     |       |
| firstname  | varchar(20) | NO   |     | NULL     |       |
| middlename | varchar(20) | YES  |     | NULL     |       |
| lastname   | varchar(20) | NO   |     | NULL     |       |
| age        | int(11)     | NO   |     | NULL     |       |
| salary     | int(11)     | NO   |     | NULL     |       |
| location   | varchar(20) | NO   |     | BANGLORE |       |
| jobtitle   | varchar(50) | YES  |     | NULL     |       |
+------------+-------------+------+-----+----------+-------+

alter table employee drop  column jobtitle ;

alter table employee drop  column jobtitle ;
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC employee;
+------------+-------------+------+-----+----------+-------+
| Field      | Type        | Null | Key | Default  | Extra |
+------------+-------------+------+-----+----------+-------+
| id         | int(11)     | NO   | PRI | NULL     |       |
| firstname  | varchar(20) | NO   |     | NULL     |       |
| middlename | varchar(20) | YES  |     | NULL     |       |
| lastname   | varchar(20) | NO   |     | NULL     |       |
| age        | int(11)     | NO   |     | NULL     |       |
| salary     | int(11)     | NO   |     | NULL     |       |
| location   | varchar(20) | NO   |     | BANGLORE |       |
+------------+-------------+------+-----+----------+-------+


alter table employee modify column firstname varchar(30);

alter table employee modify column firstname varchar(30);
Query OK, 0 rows affected (0.17 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC employee;
+------------+-------------+------+-----+----------+-------+
| Field      | Type        | Null | Key | Default  | Extra |
+------------+-------------+------+-----+----------+-------+
| id         | int(11)     | NO   | PRI | NULL     |       |
| firstname  | varchar(30) | YES  |     | NULL     |       |
| middlename | varchar(20) | YES  |     | NULL     |       |
| lastname   | varchar(20) | NO   |     | NULL     |       |
| age        | int(11)     | NO   |     | NULL     |       |
| salary     | int(11)     | NO   |     | NULL     |       |
| location   | varchar(20) | NO   |     | BANGLORE |       |
+------------+-------------+------+-----+----------+-------+


alter table employee drop primary key;


alter table employee drop primary key;
Query OK, 0 rows affected (0.18 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC employee;
+------------+-------------+------+-----+----------+-------+
| Field      | Type        | Null | Key | Default  | Extra |
+------------+-------------+------+-----+----------+-------+
| id         | int(11)     | NO   |     | NULL     |       |
| firstname  | varchar(30) | YES  |     | NULL     |       |
| middlename | varchar(20) | YES  |     | NULL     |       |
| lastname   | varchar(20) | NO   |     | NULL     |       |
| age        | int(11)     | NO   |     | NULL     |       |
| salary     | int(11)     | NO   |     | NULL     |       |
| location   | varchar(20) | NO   |     | BANGLORE |       |
+------------+-------------+------+-----+----------+-------+


alter table employee add primary key(id);


alter table employee add primary key(id);
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC employee;
+------------+-------------+------+-----+----------+-------+
| Field      | Type        | Null | Key | Default  | Extra |
+------------+-------------+------+-----+----------+-------+
| id         | int(11)     | NO   | PRI | NULL     |       |
| firstname  | varchar(30) | YES  |     | NULL     |       |
| middlename | varchar(20) | YES  |     | NULL     |       |
| lastname   | varchar(20) | NO   |     | NULL     |       |
| age        | int(11)     | NO   |     | NULL     |       |
| salary     | int(11)     | NO   |     | NULL     |       |
| location   | varchar(20) | NO   |     | BANGLORE |       |
+------------+-------------+------+-----+----------+-------+


DDL VS DML:

==================================

Data Definition Language:

Deals with table structure.

CREATE, ALTER, DROP are DDL commands.

Data Manipulation Language:

Deals with data directly.

INSERT, UPDATE, DELETE are DML commands

delete from table;

Truncate also removes all records but it is DDL command.

When you use delete it will delete the data one by one records

When we use truncate it drops the table internally and recreate again.

truncate is more effeciant than delete.

==========================================================================================================================================

SQL Session 5:

=================================================

Foreign Key Constraint;
====================================

Student Table:
===================
create table students(
student_id INT AUTO_INCREMENT,
student_fname varchar(30) NOT NULL,
student_lname varchar(30) NOT NULL,
student_mname varchar(30),
student_email varchar(30) NOT NULL,
sudent_phone varchar(15) NOT NULL,
student_alternate_phone varchar(15),
enrollment_date TIMESTAMP NOT NULL,
years_of_exp INT NOT NULL,
student_company varchar(30),
batch_date varchar(30) NOT NULL,
source_of_joining varchar(30) NOT NULL,
location varchar(30) NOT NULL,
PRIMARY KEY(student_id),
UNIQUE KEY(student_email)
);



insert into students(student_fname,student_lname,student_email,sudent_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('rohit','sharma','rohit@gmail.com','9191919191',6,'walmart','05-02-2021','linkedin','bangalore');

insert into students(student_fname,student_lname,student_email,sudent_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('virat','kohli','virat@gmail.com','9292929292',3,'flipkart','05-02-2021','linkedin','hyderabad');

insert into students(student_fname,student_lname,student_email,sudent_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('shikar','dhawan','shikar@gmail.com','9393939393',12,'19-02-2021','google','bangalore');

insert into students(student_fname,student_lname,student_email,sudent_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('rahul','dravid','rahul@gmail.com','9494949494',8,'walmart','19-02-2021','quora','chennai');

insert into students(student_fname,student_lname,student_email,sudent_phone,years_of_exp,student_company,batch_date,source_of_joining,location) values('kapil','dev','kapil@gmail.com','9294919191',15,'microsoft','05-02-2021','friend','pune'),('brain','lara','brain@gmail.com','9394919191',18,'tcs','05-02-2021','youtube','pune'),('carl','hooper','carl@gmail.com','9293519191',20,'wipro','19-02-2021','youtube','pune'),('saurabh','ganguly','saurabh@gmail.com','9291975191',14,'wipro','19-02-2021','google','chennai');



SELECT Statement;

=====================

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students;


Courses Table:

==========================

create table courses(
course_id INT NOT NULL,
course_name varchar(30) NOT NULL,
course_duration_in_months INT NOT NULL,
course_fee INT NOT NULL,
PRIMARY KEY(course_id)
);


insert into courses(course_id,course_name,course_duration_in_months,course_fee)
values(1,'bigdata',6,40000),
(2,'webdevelopment',3,20000),
(3,'datascience',6,50000),
(4,'devops',1,10000);


Student Table:
===================
create table students(
student_id INT AUTO_INCREMENT,
student_fname varchar(30) NOT NULL,
student_lname varchar(30) NOT NULL,
student_mname varchar(30),
student_email varchar(30) NOT NULL,
sudent_phone varchar(15) NOT NULL,
student_alternate_phone varchar(15),
enrollment_date TIMESTAMP NOT NULL,
selected_course INT NOT NULL DEFAULT 1,
years_of_exp INT NOT NULL,
student_company varchar(30),
batch_date varchar(30) NOT NULL,
source_of_joining varchar(30) NOT NULL,
location varchar(30) NOT NULL,
PRIMARY KEY(student_id),
UNIQUE KEY(student_email)
);




 


Creating Table with Foreign Key constraint:
==============================================


create table students(
student_id INT AUTO_INCREMENT,
student_fname varchar(30) NOT NULL,
student_lname varchar(30) NOT NULL,
student_mname varchar(30),
student_email varchar(30) NOT NULL,
sudent_phone varchar(15) NOT NULL,
student_alternate_phone varchar(15),
enrollment_date TIMESTAMP NOT NULL,
selected_course INT NOT NULL DEFAULT 1,
years_of_exp INT NOT NULL,
student_company varchar(30),
batch_date varchar(30) NOT NULL,
source_of_joining varchar(30) NOT NULL,
location varchar(30) NOT NULL,
PRIMARY KEY(student_id),
UNIQUE KEY(student_email),
FOREIGN KEY(selected_course) REFERENCES courses(course_id)
);


parent - courses

child - students


The foreign key constraint is used to prevent actions that would destroy links between two tables.

Fore Key is the field in one table that refers to primary key in other table.

selected_course is foreign key in students table which refers to course_id in courses table.

the table with foreign key is called child table and the key with primary key is called reference table or parent table.

constraint are used to limit the type of data tht can go into table

this ensures the accuracy and reliability of the data is maintained.

if there is any violation then the action is aborted.
===========================================================================================================================================
Session 6:

=================================

Distinct

ORDER BY

Limit

Like

Distinct:

===============================


mysql> select distinct(location) from students;
+-----------+
| location  |
+-----------+
| bangalore |
| chennai   |
| pune      |
+-----------+
3 rows in set (0.00 sec)


select distinct(student_company) from students;
+-----------------+
| student_company |
+-----------------+
| walmart         |
| microsoft       |
| tcs             |
| wipro           |
+-----------------+


select distinct(source_of_joining) from students;


select distinct(source_of_joining) from students;
+-------------------+
| source_of_joining |
+-------------------+
| linkedin          |
| quora             |
| friend            |
| youtube           |
| google            |
+-------------------+

ORDER BY:

====================================

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students order by years_of_exp;
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
| student_id | enrollment_date     | student_fname | student_email     | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
|          1 | 2022-07-09 00:03:08 | rohit         | rohit@gmail.com   |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com   |            8 | walmart         | 19-02-2021 | quora             | chennai   |
|          6 | 2022-07-09 00:03:09 | saurabh       | saurabh@gmail.com |           14 | wipro           | 19-02-2021 | google            | chennai   |
|          3 | 2022-07-09 00:03:09 | kapil         | kapil@gmail.com   |           15 | microsoft       | 05-02-2021 | friend            | pune      |
|          4 | 2022-07-09 00:03:09 | brain         | brain@gmail.com   |           18 | tcs             | 05-02-2021 | youtube           | pune      |
|          5 | 2022-07-09 00:03:09 | carl          | carl@gmail.com    |           20 | wipro           | 19-02-2021 | youtube           | pune      |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+



select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students o
rder by years_of_exp desc; 
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
| student_id | enrollment_date     | student_fname | student_email     | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
|          5 | 2022-07-09 00:03:09 | carl          | carl@gmail.com    |           20 | wipro           | 19-02-2021 | youtube           | pune      |
|          4 | 2022-07-09 00:03:09 | brain         | brain@gmail.com   |           18 | tcs             | 05-02-2021 | youtube           | pune      |
|          3 | 2022-07-09 00:03:09 | kapil         | kapil@gmail.com   |           15 | microsoft       | 05-02-2021 | friend            | pune      |
|          6 | 2022-07-09 00:03:09 | saurabh       | saurabh@gmail.com |           14 | wipro           | 19-02-2021 | google            | chennai   |
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com   |            8 | walmart         | 19-02-2021 | quora             | chennai   |
|          1 | 2022-07-09 00:03:08 | rohit         | rohit@gmail.com   |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+


select student_fname from students order by years_of_exp;
+---------------+
| student_fname |
+---------------+
| rohit         |
| rahul         |
| saurabh       |
| kapil         |
| brain         |
| carl          |
+---------------+

select student_fname,years_of_exp  from students order by years_of_exp;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| rohit         |            6 |
| rahul         |            8 |
| saurabh       |           14 |
| kapil         |           15 |
| brain         |           18 |
| carl          |           20 |
+---------------+--------------+

select student_fname,years_of_exp  from students order by years_of_exp desc;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| carl          |           20 |
| brain         |           18 |
| kapil         |           15 |
| saurabh       |           14 |
| rahul         |            8 |
| rohit         |            6 |
+---------------+--------------+


select student_fname,years_of_exp  from students order by 2 ;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| rohit         |            6 |
| rahul         |            8 |
| saurabh       |           14 |
| kapil         |           15 |
| brain         |           18 |
| carl          |           20 |
+---------------+--------------+
6 rows in set (0.00 sec)

mysql> select student_fname,years_of_exp  from students order by 1;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| brain         |           18 |
| carl          |           20 |
| kapil         |           15 |
| rahul         |            8 |
| rohit         |            6 |
| saurabh       |           14 |
+---------------+--------------+


select student_fname,years_of_exp  from students order by 1 desc;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| saurabh       |           14 |
| rohit         |            6 |
| rahul         |            8 |
| kapil         |           15 |
| carl          |           20 |
| brain         |           18 |
+---------------+--------------+



select student_fname,years_of_exp  from students order by years_of_exp,student_fname;
+---------------+--------------+
| student_fname | years_of_exp |
+---------------+--------------+
| rohit         |            6 |
| rahul         |            8 |
| saurabh       |           14 |
| kapil         |           15 |
| brain         |           18 |
| carl          |           20 |
+---------------+--------------+


LIMIT:

==============================================

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students order by years_of_exp limit 3;
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
| student_id | enrollment_date     | student_fname | student_email     | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+
|          1 | 2022-07-09 00:03:08 | rohit         | rohit@gmail.com   |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com   |            8 | walmart         | 19-02-2021 | quora             | chennai   |
|          6 | 2022-07-09 00:03:09 | saurabh       | saurabh@gmail.com |           14 | wipro           | 19-02-2021 | google            | chennai   |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+-----------+

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students o
rder by years_of_exp desc limit 3;;
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
| student_id | enrollment_date     | student_fname | student_email   | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
|          5 | 2022-07-09 00:03:09 | carl          | carl@gmail.com  |           20 | wipro           | 19-02-2021 | youtube           | pune     |
|          4 | 2022-07-09 00:03:09 | brain         | brain@gmail.com |           18 | tcs             | 05-02-2021 | youtube           | pune     |
|          3 | 2022-07-09 00:03:09 | kapil         | kapil@gmail.com |           15 | microsoft       | 05-02-2021 | friend            | pune     |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
3 rows in set (0.00 sec)

Want to know which sources last 5 candidates have enrolled.


select source_of_joining from students order by enrollment_date desc limit 5;
+-------------------+
| source_of_joining |
+-------------------+
| friend            |
| youtube           |
| youtube           |
| google            |
| linkedin          |

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students order by enrollment_date desc limit 1;
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+
| student_id | enrollment_date     | student_fname | student_email     | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+
|          6 | 2022-07-09 00:03:09 | saurabh       | saurabh@gmail.com |           14 | wipro           | 19-02-2021 | google            | chennai  |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+


 select * from students order by enrollment_date desc limit 0, 3;
+------------+---------------+---------------+---------------+-------------------+--------------+-------------------------+---------------------+------
-----------+--------------+-----------------+------------+-------------------+----------+
| student_id | student_fname | student_lname | student_mname | student_email     | sudent_phone | student_alternate_phone | enrollment_date     | selec
ted_course | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------+---------------+---------------+-------------------+--------------+-------------------------+---------------------+------
-----------+--------------+-----------------+------------+-------------------+----------+
|          6 | saurabh       | ganguly       | NULL          | saurabh@gmail.com | 9291975191   | NULL                    | 2022-07-09 00:03:09 |
         3 |           14 | wipro           | 19-02-2021 | google            | chennai  |
|          5 | carl          | hooper        | NULL          | carl@gmail.com    | 9293519191   | NULL                    | 2022-07-09 00:03:09 |
         1 |           20 | wipro           | 19-02-2021 | youtube           | pune     |
|          3 | kapil         | dev           | NULL          | kapil@gmail.com   | 9294919191   | NULL                    | 2022-07-09 00:03:09 |
         4 |           15 | microsoft       | 05-02-2021 | friend            | pune     |
+------------+---------------+---------------+---------------+-------------------+--------------+-------------------------+---------------------+------
-----------+--------------+-----------------+------------+-------------------+----------+
3 rows in set (0.00 sec)

mysql> select * from students order by enrollment_date desc limit 3,2;
+------------+---------------+---------------+---------------+-------------------+--------------+-------------------------+---------------------+------
-----------+--------------+-----------------+------------+-------------------+-----------+
| student_id | student_fname | student_lname | student_mname | student_email     | sudent_phone | student_alternate_phone | enrollment_date     | selec
ted_course | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------+---------------+---------------+-------------------+--------------+-------------------------+---------------------+------
-----------+--------------+-----------------+------------+-------------------+-----------+
|          6 | saurabh       | ganguly       | NULL          | saurabh@gmail.com | 9291975191   | NULL                    | 2022-07-09 00:03:09 |
         3 |           14 | wipro           | 19-02-2021 | google            | chennai   |
|          1 | rohit         | sharma        | NULL          | rohit@gmail.com   | 9191919191   | NULL                    | 2022-07-09 00:03:08 |
         3 |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
+------------+---------------+---------------+---------------+-------------------+--------------+-------------------------+---------------------+------
-----------+--------------+-----------------+------------+-------------------+-----------+
2 rows in set (0.00 sec)


LIKE:

=============================================


select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students where student_fname like '%ra%';
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+
| student_id | enrollment_date     | student_fname | student_email     | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com   |            8 | walmart         | 19-02-2021 | quora             | chennai  |
|          4 | 2022-07-09 00:03:09 | brain         | brain@gmail.com   |           18 | tcs             | 05-02-2021 | youtube           | pune     |
|          6 | 2022-07-09 00:03:09 | saurabh       | saurabh@gmail.com |           14 | wipro           | 19-02-2021 | google            | chennai  |
+------------+---------------------+---------------+-------------------+--------------+-----------------+------------+-------------------+----------+


 select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students w
here student_fname like 'ra%';
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
| student_id | enrollment_date     | student_fname | student_email   | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com |            8 | walmart         | 19-02-2021 | quora             | chennai  |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+----------+
1 row in set (0.00 sec)

select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students w
here student_fname like '%it';
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
| student_id | enrollment_date     | student_fname | student_email   | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
|          1 | 2022-07-09 00:03:08 | rohit         | rohit@gmail.com |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
1 row in set (0.00 sec)


select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students w
here student_fname like '_____';
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
| student_id | enrollment_date     | student_fname | student_email   | years_of_exp | student_company | batch_date | source_of_joining | location  |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+
|          1 | 2022-07-09 00:03:08 | rohit         | rohit@gmail.com |            6 | walmart         | 05-02-2021 | linkedin          | bangalore |
|          2 | 2022-07-09 00:03:08 | rahul         | rahul@gmail.com |            8 | walmart         | 19-02-2021 | quora             | chennai   |
|          3 | 2022-07-09 00:03:09 | kapil         | kapil@gmail.com |           15 | microsoft       | 05-02-2021 | friend            | pune      |
|          4 | 2022-07-09 00:03:09 | brain         | brain@gmail.com |           18 | tcs             | 05-02-2021 | youtube           | pune      |
+------------+---------------------+---------------+-----------------+--------------+-----------------+------------+-------------------+-----------+

 select student_id,enrollment_date,student_fname,student_email,years_of_exp,student_company,batch_date,source_of_joining,location from students w
here student_fname like '____';
+------------+---------------------+---------------+----------------+--------------+-----------------+------------+-------------------+----------+
| student_id | enrollment_date     | student_fname | student_email  | years_of_exp | student_company | batch_date | source_of_joining | location |
+------------+---------------------+---------------+----------------+--------------+-----------------+------------+-------------------+----------+
|          5 | 2022-07-09 00:03:09 | carl          | carl@gmail.com |           20 | wipro           | 19-02-2021 | youtube           | pune     |
+------------+---------------------+---------------+----------------+--------------+-----------------+------------+-------------------+----------+

% and _ are wild card characters.
=====================================================================================================================================================================
Session 7:

=============================

select distinct source_of_joing from students order by enrollment_date desc;

Distinct and Order By in the same Query.


case 1:

select source_of_joing from students

Order of execution:
=============================

1) From (Loading the Table)

2) Select (Projecting source_of_joining)

case 2:

select source_of_joing, enrollment_date from students.

Order of execution:
=============================

1) From (Loading the Table)

2) Select (Projecting source_of_joining and source_of_joining)

case 3:

select source_of_joing, enrollment_date from students order by enrollment_date;

Order of execution:
=============================

1) From (Loading the Table)

2) Select (Projecting source_of_joining and source_of_joining)

3) Order By (based on enrollment_date it will order by)


case 4:

select source_of_joing from students order by enrollment_date;


Order of execution:
=============================

1) From (Loading the Table)

2) Select (Projecting source_of_joining , enrollment_date)

3) Order By (based on enrollment_date it will order by)



case 5:

select distinct source_of_joining from students order by enrollment_date;

Order of execution:
=============================

1) From (Loading the Table)

2) Select (Projecting source_of_joining , enrollment_date)

select source_of_joining,enrollment_date from students;

3) distinct 

select distinct source_of_joining,enrollment_date from students;

3) Order By (based on enrollment_date it will order by)
============================================================================================================================================
Session 8:
================================

Aggregate Functions:

====================================

COUNT:

=========================

mysql> select count(*) from students;
+----------+
| count(*) |
+----------+
|        6 |
+----------+
1 row in set (0.00 sec)

mysql> select count(DISTINCT srudent_company) from students;
ERROR 1054 (42S22): Unknown column 'srudent_company' in 'field list'
mysql> select count(DISTINCT student_company) from students;
+---------------------------------+
| count(DISTINCT student_company) |
+---------------------------------+
|                               4 |
+---------------------------------+
1 row in set (0.00 sec)

mysql> select count(DISTINCT student_company) as num_companies from students;
+---------------+
| num_companies |
+---------------+
|             4 |
+---------------+
1 row in set (0.00 sec)



select count(DISTINCT location) from students;
+--------------------------+
| count(DISTINCT location) |
+--------------------------+
|                        3 |
+--------------------------+
1 row in set (0.00 sec)

mysql> select count(DISTINCT source_of_joining) from students;
+-----------------------------------+
| count(DISTINCT source_of_joining) |
+-----------------------------------+
|                                 5 |
+-----------------------------------+

mysql> select count(*) from students where batch_date like '19%';
+----------+
| count(*) |
+----------+
|        3 |
+----------+
1 row in set (0.00 sec)


GROUP BY VIMP:

===========================================

Waht I want to use to know how many people  joined my course thorugh 

Linked 5

google 4

quora 3

Needs to group by source_of_joining


 select source_of_joining, count(*) from students group by source_of_joining;
+-------------------+----------+
| source_of_joining | count(*) |
+-------------------+----------+
| friend            |        1 |
| google            |        1 |
| linkedin          |        1 |
| quora             |        1 |
| youtube           |        2 |
+-------------------+----------+

select location, count(*) from students group by location;
+-----------+----------+
| location  | count(*) |
+-----------+----------+
| bangalore |        1 |
| chennai   |        2 |
| pune      |        3 |
+-----------+----------+
3 rows in set (0.00 sec)


 
select location, count(*) from students group by source_of_joining; This is will not work.


 select location,source_of_joining,count(*) from students  group by location,source_of_joining;
+-----------+-------------------+----------+
| location  | source_of_joining | count(*) |
+-----------+-------------------+----------+
| bangalore | linkedin          |        1 |
| chennai   | google            |        1 |
| chennai   | quora             |        1 |
| pune      | friend            |        1 |
| pune      | youtube           |        2 |
+-----------+-------------------+----------+

 select selected_course, count(*) from students GROUP BY selected_course;
+-----------------+----------+
| selected_course | count(*) |
+-----------------+----------+
|               1 |        2 |
|               2 |        1 |
|               3 |        2 |
|               4 |        1 |
+-----------------+----------+

select batch_date,selected_course,count(*) from students GROUP BY batch_date,selected_course;
+------------+-----------------+----------+
| batch_date | selected_course | count(*) |
+------------+-----------------+----------+
| 05-02-2021 |               2 |        1 |
| 05-02-2021 |               3 |        1 |
| 05-02-2021 |               4 |        1 |
| 19-02-2021 |               1 |        2 |
| 19-02-2021 |               3 |        1 |
+------------+-----------------+----------+


MIN & MAX:

===========================

 select MIN(years_of_exp) from students;
+-------------------+
| MIN(years_of_exp) |
+-------------------+
|                 6 |
+-------------------+
1 row in set (0.00 sec)

mysql> select MAX(years_of_exp) from students;
+-------------------+
| MAX(years_of_exp) |
+-------------------+
|                20 |
+-------------------+
1 row in set (0.00 sec)


Each Source Of joining I want to get max :

select source_of_joining,max(years_of_exp) from students group by source_of_joining;
+-------------------+-------------------+
| source_of_joining | max(years_of_exp) |
+-------------------+-------------------+
| friend            |                15 |
| google            |                14 |
| linkedin          |                 6 |
| quora             |                 8 |
| youtube           |                20 |
+-------------------+-------------------+

SUM:

=====================================

select source_of_joining, sum(years_of_exp) from students group by source_of_joining;
+-------------------+-------------------+
| source_of_joining | sum(years_of_exp) |
+-------------------+-------------------+
| friend            |                15 |
| google            |                14 |
| linkedin          |                 6 |
| quora             |                 8 |
| youtube           |                38 |
+-------------------+-------------------+

AVG:

===============================

select source_of_joining, avg(years_of_exp) from students group by source_of_joining;
+-------------------+-------------------+
| source_of_joining | avg(years_of_exp) |
+-------------------+-------------------+
| friend            |           15.0000 |
| google            |           14.0000 |
| linkedin          |            6.0000 |
| quora             |            8.0000 |
| youtube           |           19.0000 |
+-------------------+-------------------+

select location, avg(years_of_exp) from students group by location;
+-----------+-------------------+
| location  | avg(years_of_exp) |
+-----------+-------------------+
| bangalore |            6.0000 |
| chennai   |           11.0000 |
| pune      |           17.6667 |
+-----------+-------------------+


select student_company, avg(years_of_exp) from students group by student_company;

select student_company, avg(years_of_exp) from students group by student_company;
+-----------------+-------------------+
| student_company | avg(years_of_exp) |
+-----------------+-------------------+
| microsoft       |           15.0000 |
| tcs             |           18.0000 |
| walmart         |            7.0000 |
| wipro           |           17.0000 |
+-----------------+-------------------+
==============================================================================================================================================

Session 9:
===============================================

create table courses_new(
course_id int AUTO_INCREMENT,
course_name varchar(30) NOT NULL,
course_duration_months decimal(3,1) NOT NULL,
course_fee int NOT NULL,
PRIMARY KEY(course_id)
);

insert into courses_new(course_name,course_duration_months,course_fee) values('bigdata', 6.5, 50000),('webdevelopment', 3.5, 20000),('datascience', 6, 40000);

insert into courses_new(course_name,course_duration_months,course_fee) values('devops', 10.5, 30000);

update courses_new set course_fee = 40000 where course_id = 2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from courses_new;
+-----------+----------------+------------------------+------------+
| course_id | course_name    | course_duration_months | course_fee |
+-----------+----------------+------------------------+------------+
|         1 | bigdata        |                    6.5 |      50000 |
|         2 | webdevelopment |                    3.5 |      40000 |
|         3 | datascience    |                    6.0 |      40000 |
+-----------+----------------+------------------------+------------+
3 rows in set (0.00 sec)

create table courses_new(
course_id int AUTO_INCREMENT,
course_name varchar(30) NOT NULL,
course_duration_months decimal(3,1) NOT NULL,
course_fee int NOT NULL,
changed_at TIMESTAMP DEFAULT NOW(),
PRIMARY KEY(course_id)
);

mysql> update courses_new set course_duration_months = 4.5 where course_id = 3;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from courses_new;
+-----------+----------------+------------------------+------------+---------------------+
| course_id | course_name    | course_duration_months | course_fee | changed_at          |
+-----------+----------------+------------------------+------------+---------------------+
|         1 | bigdata        |                    6.5 |      50000 | 2022-07-11 00:01:52 |
|         2 | webdevelopment |                    3.5 |      20000 | 2022-07-11 00:01:52 |
|         3 | datascience    |                    4.5 |      40000 | 2022-07-11 00:01:52 |
+-----------+----------------+------------------------+------------+---------------------+
3 rows in set (0.00 sec)

create table courses_new(
course_id int AUTO_INCREMENT,
course_name varchar(30) NOT NULL,
course_duration_months decimal(3,1) NOT NULL,
course_fee int NOT NULL,
changed_at TIMESTAMP DEFAULT NOW() ON UPDATE CURRENT_TIMESTAMP(),
PRIMARY KEY(course_id)
);

update courses_new set course_fee = 40000 where course_id = 2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from courses_new;
+-----------+----------------+------------------------+------------+---------------------+
| course_id | course_name    | course_duration_months | course_fee | changed_at          |
+-----------+----------------+------------------------+------------+---------------------+
|         1 | devops         |                   10.5 |      30000 | 2022-07-11 00:08:30 |
|         2 | bigdata        |                    6.5 |      40000 | 2022-07-11 00:09:13 |
|         3 | webdevelopment |                    3.5 |      20000 | 2022-07-11 00:08:58 |
|         4 | datascience    |                    6.0 |      40000 | 2022-07-11 00:08:58 |
+-----------+----------------+------------------------+------------+---------------------+
4 rows in set (0.00 sec)

DECIMAL(5,3)

TIMESTAMP CURRENT_TIMESTAMP
==========================================================================================================================================

Session 10:
========================

select * from students where location = 'bangalore';

To Get people who are not from bangalore:


select * from students where location != 'bangalore';


seelct * from courses;

get all the courses which has word data.

select * from courses where course_name like "%data%";


select * from courses where course_name like "%data%";
+-----------+-------------+---------------------------+------------+
| course_id | course_name | course_duration_in_months | course_fee |
+-----------+-------------+---------------------------+------------+
|         1 | bigdata     |                         6 |      40000 |
|         3 | datascience |                         6 |      50000 |
|         5 | database    |                         4 |       3000 |
+-----------+-------------+---------------------------+------------+


get all courses which do not have the word keyword:


select * from courses where course_name not like "%data%";


select * from courses where course_name not like "%data%";
+-----------+----------------+---------------------------+------------+
| course_id | course_name    | course_duration_in_months | course_fee |
+-----------+----------------+---------------------------+------------+
|         2 | webdevelopment |                         3 |      20000 |
|         4 | devops         |                         1 |      10000 |
+-----------+----------------+---------------------------+------------+


All students from bangalore who joined through linked in and having less than 8 years of exp;

select * from students where years_of_exp < 8 and and source_of_joining = 'linkedin' and location='bangalore';


I want all people who do not fall between 8 to 12 years of exp;

select * from students where years_of_exp<8 or years_of_exp>12;

select * from students where years_of_exp not between 8 and 12;


List of students for flipkart walmart or microsoft

select * from students where student_company in ('flipkart','walmart','microsoft');

select * from students where student_company not in ('flipkart','walmart','microsoft');


If course more than 4 months we categorize as Master's program else diploma program.





select course_id,course_name,course_fee,
CASE
    WHEN course_duration_in_months > 4 THEN 'masters'
	ELSE 'diploma'
END as course_type from courses;



select course_id,course_name,course_fee,
    -> CASE
    ->     WHEN course_duration_in_months > 4 THEN 'masters'
    -> ELSE 'diploma'
    -> END as course_type from courses;
+-----------+----------------+------------+-------------+
| course_id | course_name    | course_fee | course_type |
+-----------+----------------+------------+-------------+
|         1 | bigdata        |      40000 | masters     |
|         2 | webdevelopment |      20000 | diploma     |
|         3 | datascience    |      50000 | masters     |
|         4 | devops         |      10000 | diploma     |
|         5 | database       |       3000 | diploma     |
+-----------+----------------+------------+-------------+


People working for walmart , flipkar and microsoft we want to say product based else sevrice based


select student_id,student_fname,student_lname,student_company,
CASE
    WHEN student_company in ('flipkart','walmart','microsoft') THEN 'product based'
	ELSE 'service based'
END as company_type from students;

=========================================================================================================================================

-----
JOINS
-----

-- Find the course in which students are enrolled
SELECT student_fname, student_lname, selected_course, course_name FROM students s 
JOIN courses c ON s.selected_course = c.course_id;

** By default, it is a INNER JOIN

** INNER JOIN : only the matching records will be considered and non-matching records will be discarded

---------------
LEFT OUTER JOIN
---------------

*** All the matching records from left and right table are considered + 
   All the non matching records in the left table which does not have the match in the right padded with NULL

** For LEFT OUTER JOIN to happen, we must have some extra records in the left table(T1) 

** T1(Left Table) X T2(Right Table)

-- Delete the course having course_id = 2 

DELETE FROM courses WHERE course_id = 2;

Error: ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`trendytech`.`students`, CONSTRAINT `students_ibfk_1` FOREIGN KEY (`selected_course`) REFER
ENCES `courses` (`course_id`))

* The above DELETE query won't work because it is attached with the students table also in the form of FOREIGN KEY

* If we try to delete the course having course_id = 2, then the student who has enrolled for course_id = 2 will become obsolete

-- Now, we will create a new students table and new couses table with same data but FOREIGN key constraint won't be there

CREATE TABLE students_latest AS SELECT * FROM students;
CREATE TABLE courses_latest AS SELECT * FROM courses;

-- Now, we can delete the records from courses table

-- Delete the course having course_id = 2 

DELETE FROM courses_latest WHERE course_id = 2;

-- What will happen if we perform INNER JOIN on the above created table

-- Find the course in which students are enrolled
SELECT student_fname, student_lname, selected_course, course_name FROM students_latest s 
JOIN courses_latest c ON s.selected_course = c.course_id;

-- Now, lets perform a LEFT OUTER JOIN

** How to perform a LEFT OUTER JOIN?
==> We just have to give the keyword LEFT before JOIN

-- Find the course in which students are enrolled
SELECT student_fname, student_lname, selected_course, course_name FROM students_latest s 
LEFT JOIN courses_latest c ON s.selected_course = c.course_id;

----------------
RIGHT OUTER JOIN
----------------

*** All the matching records from left and right table are considered + 
   All the non matching records in the right table which does not have the match in the left padded with NULL

** For RIGHT OUTER JOIN to happen, we must have some extra records in the right table(T2) 

** T1(Left Table) X T2(Right Table)
** How to perform a RIGHT OUTER JOIN?
==> We just have to give the keyword RIGHT before JOIN

-- Find the course in which students are enrolled
SELECT student_fname, student_lname, selected_course, course_name FROM students_latest s 
RIGHT JOIN courses_latest c ON s.selected_course = c.course_id;

---------------
FULL OUTER JOIN
---------------

* Combination of LEFT OUTER JOIN and RIGHT OUTER JOIN.

* FULL OUTER JOIN = LEFT OUTER JOIN UNION RIGHT OUTER JOIN

* All the matching records + Non-matching records from left + Non-matching records from right

* In SQL, we do not have keyword FULL for FULL OUTER JOIN, so we will do UNION of LEFT OUTER JOIN and RIGHT OUTER JOIN

SELECT student_fname, student_lname, selected_course, course_name FROM students_latest s 
LEFT JOIN courses_latest c ON s.selected_course = c.course_id
UNION
SELECT student_fname, student_lname, selected_course, course_name FROM students_latest s 
RIGHT JOIN courses_latest c ON s.selected_course = c.course_id;

----------
CROSS JOIN
----------
* CROSS JOIN is costly as each record of first table is getting combined with each record of second table.

If Left Table (T1) has 4 records 
If Right Table (T2) has 5 records

Then, CROSS JOIN = 4 * 5 = 20 records, 1 to 1 mapping with each records

SELECT COUNT(*) FROM students, courses; 
-- 35 records

SELECT COUNT(*) FROM students JOIN courses;
-- 35 records

SELECT COUNT(*) FROM students;
-- 7 records

SELECT COUNT(*) FROM courses;
-- 5 records

==========================================================================================================================================

-----------------------------
WHERE vs HAVING clause in SQL
-----------------------------

-- Find the source_of_joining through which more than 1 student has enrolled

SELECT source_of_joining, COUNT(*) AS total from students GROUP BY source_of_joining WHERE total > 1;

Error: ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'WHERE total > 1' at
line 1

** WHERE clause is used to filter the individual records before GROUP BY or aggregation.

SELECT source_of_joining, COUNT(*) AS total from students GROUP BY source_of_joining HAVING total > 1;

** HAVING clause is used to filter the records after GROUP BY or aggregation.

--  Find the total number of students who have enrolled through linkedin as source_of_joining

-- OPTIMISED QUERY (Filtering is happening before aggregation)
SELECT source_of_joining, COUNT(*) AS total FROM students WHERE source_of_joining = 'linkedin' GROUP BY source_of_joining;

or

-- NON-OPTIMISEZ QUERY (Filtering is happening after aggregation)
SELECT source_of_joining, COUNT(*) AS total FROM students GROUP BY source_of_joining HAVING source_of_joining = 'linkedin';

------------------------------------------------------
Can we use WHERE and HAVING clause in the same query ?
------------------------------------------------------

-- Find the locations from which more than 1 student has joined & the students years_of_exp is more than 5 years

SELECT location, COUNT(*) AS total from students WHERE years_of_exp > 5 GROUP BY location HAVING total > 1;

========================================================================
** WHERE is used before GROUP BY and do filtering on individual records.

** HAVING is used after GROUP BY and do filtering on aggregated records.

** We can use WHERE and HAVING in the same query also.

** WHERE is more performant than HAVING.

===========================================================================================================================================

----------------------------
OVER and PARTITION BY clause
----------------------------

-- From here we won't use goorm IDE, because that was using older versions of MySQL instead we will use https://onecompiler.com/mysql

CREATE TABLE employee(
    firstname varchar(20),
    lastname varchar(20),
    age int,
    salary int,
    location varchar(20)
);

INSERT INTO employee VALUES
('Sachin', 'Sharma', 28, 10000, 'Bangalore'),
('Rohit', 'Sharma', 30, 20000, 'Hyderabad'),
('Virat', 'Kohli', 29, 30000, 'Chennai'),
('Akshay', 'Kumar', 32, 40000, 'Banagalore'),
('Sunil', 'Shetty', 34, 50000, 'Hyderabad'),
('Mark', 'John', 34, 50000, 'Bangalore');

-- How many people are from each location and average salary at each location

-- Bangalore, 4, 19999 (Example)

SELECT location, COUNT(location) AS total, AVG(salary) AS average from employee GROUP BY location;

-- Fetch the firstname, latname and how many people are from each location and average salary at each location

SELECT firstname, lastname, location, COUNT(location) AS total, AVG(salary) AS average from employee GROUP BY location;

ERROR 1055 (42000) at line 19: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'db_3ye8guejd.employee.firstname' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

-- We can try achieving it using a JOIN

SELECT firstname, lastname, employee.location, total_count, avg_salary FROM employee JOIN 
(SELECT location, COUNT(location) AS total_count, AVG(salary) AS avg_salary from employee GROUP BY location) temptable ON 
employee.location = temptable.location;

-- Is there any other way to perform above query?

==> We can use OVER PARTITION BY to achieve this easily

** PARTITION BY is useful while performing operations on Non-Aggregate columns

SELECT firstname, lastname, location, 
COUNT(location) OVER (PARTITION BY location) AS total, 
AVG(salary) OVER (PARTITION BY location) AS average 
FROM employee;

===========================================================================================================================================

-------------------
ROW NUMBER FUNCTION
-------------------

CREATE TABLE employee(
    firstname varchar(20),
    lastname varchar(20),
    age int,
    salary int,
    location varchar(20)
);

INSERT INTO employee VALUES
('Sachin', 'Sharma', 28, 10000, 'Bangalore'),
('Shane', 'Warne', 30, 20000, 'Bangalore'),
('Rohit', 'Sharma', 32, 30000, 'Hyderabad'),
('Shikhar', 'Dhawan', 32, 25000, 'Hyderabad'),
('Rahul', 'Dravid', 31, 20000, 'Banagalore'),
('Saurabh', 'Ganguly', 32, 15000, 'Pune'),
('Kapil', 'Dev', 34, 10000, 'Pune');

=====================================
SELECT firstname, lastname, salary, 
row_number() as rownum OVER (ORDER BY salary DESC) FROM employee;

** ROW_NUMBER() won't work without ORDER BY 

-- Find the record having 5th highest salary

SELECT * FROM (SELECT firstname, lastname, salary, 
row_number() OVER (ORDER BY salary DESC) AS rownum FROM employee) temptable WHERE rownum = 5;

-- Assign row number for partitions based on each location

SELECT firstname, lastname, location, salary, row_number() OVER (PARTITION BY location ORDER BY salary DESC) FROM employee; 

-- Find the candidate having highest salary from each location

SELECT * FROM (SELECT firstname, lastname, location, salary, 
row_number() OVER (PARTITION BY location ORDER BY salary DESC) AS rownum 
FROM employee) temptable
WHERE rownum = 1;

===============================================================================
** When we use ROW_NUMBER, we must use ORDER BY clause otherwise it won't work
** When we use ROW_NUMBER, we may/may not use the PARTITION BY
** The ROW_NUMBER starts from 1 for each partition
** ROW_NUMBER will assign the number uniquely even though there are duplicate data in the records

===========================================================================================================================================

-----------------
RANK & DENSE RANK
-----------------

CREATE TABLE employee(
    firstname varchar(20),
    lastname varchar(20),
    age int,
    salary int,
    location varchar(20)
);

INSERT INTO employee VALUES
('Sachin', 'Sharma', 28, 10000, 'Bangalore'),
('Shane', 'Warne', 30, 20000, 'Bangalore'),
('Rohit', 'Sharma', 32, 30000, 'Hyderabad'),
('Shikhar', 'Dhawan', 32, 25000, 'Hyderabad'),
('Rahul', 'Dravid', 31, 21000, 'Banagalore'),
('Saurabh', 'Ganguly', 32, 15000, 'Pune'),
('Kapil', 'Dev', 34, 10000, 'Pune');

----------------------------------------
** Ideally, we should use ROW_NUMBER when there are no duplicate records
** Like in ROW_NUMBER, ORDER BY is mandatory for RANK & DENSE_RANK
-- Like in the above Example, Sachin and Kapil are having same salary so which one will get which row number we don't know.
-- ROW_NUMBER do not handles duplicate, so we have RANK & DENSE RANK

-- With ROW_NUMBER()
SELECT firstname, lastname, salary, 
row_number() OVER (ORDER BY salary DESC) FROM employee;

-- With RANK()
SELECT firstname, lastname, salary, 
RANK() OVER (ORDER BY salary DESC) FROM employee;

-- With DENSE_RANK()
SELECT firstname, lastname, salary, 
DENSE_RANK() OVER (ORDER BY salary DESC) FROM employee;

** RANK() will skip assigning row numbers to records when there are duplicate data in the records.
** RANK() will assign the same rank for duplicate data in the records.

** DENSE_RANK() will assign the row numbers in sequence even when there are duplicate data in the records.

** When there are no duplicate data in the records, ROW_NUMBER(), RANK() and DENSE_RANK() all of them will give the same result.

====================================================================
** When there are no duplicates in the records then use ROW_NUMBER

When should we use the DENSE_RANK() ?

-- Consider the usecase when we have to find the top 3 positions in some competition, then as per DENSE_RANK(), we will have the
below ranks

Candidate 1 score = 100 ==> 1
Candidate 2 score = 100 ==> 1
Candidate 3 score = 98 ==> 2
Candidate 4 score = 97 ==> 3
Candidate 5 score = 97 ==> 3
Candidate 6 score = 96 ==> 4

-- Find the person having rank = 4

SELECT * FROM (SELECT firstname, lastname, salary, 
DENSE_RANK() OVER (ORDER BY salary DESC) AS rownum from employee) temptable WHERE rownum = 4;


===============================================================================================================================================

Common table expression (CTE)
==============================

this is to simplify the complex queries.

it improves the readability of a query

Orders table
=============

order_id, order_data, order_customer_id, order_status

total orders each customer has placed

I want to find out premium customers (who places more orders)


average number of numbers placed by each customer

Solution 1 (subquery)
======================

select avg(total_orders_per_customer) as avg_orders_per_customer from (
select order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id) x


Solution 2 (CTE/WITH CLAUSE)
============================

WITH total_orders (order_customer_id,total_orders_per_customer) as
(select order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id)

select avg(total_orders_per_customer) as avg_orders_per_customer from total_orders

subquery
==========
query3(query2(query1))

CTE
====
query1

query2

query3


I want to find premium customers who places more orders than the average number of orders
===================

select * from (select order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id) total_orders join(select avg(total_orders_per_customer) as avg_orders_per_customer from (
select order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id) x) average_orders on total_orders.total_orders_per_customer > average_orders.avg_orders_per_customer


3 step process
===============
1. calculate total orders per customer
2. calculate average number of number orders for the customers
3. get to know the customers who are premium

WITH total_orders(order_customer_id, total_orders_per_customer) as
(select order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id),
average_orders(avg_orders_per_customer) as
(select avg(total_orders_per_customer) as avg_orders_per_customer from total_orders)
select * from orders;
select * from total_orders join average_orders on total_orders.total_orders_per_customer  >  average_orders.avg_orders_per_customer;


CTE defines a temporary resultset that you can refer in select, insert, update, delete statements immedicate follows the CTE



WITH total_orders(order_customer_id, order_customer_id1, total_orders_per_customer) as
(select order_customer_id, order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id),
average_orders(avg_orders_per_customer) as
(select avg(total_orders_per_customer) as avg_orders_per_customer from total_orders)
select * from total_orders join average_orders on total_orders.total_orders_per_customer  >  average_orders.avg_orders_per_customer;


====================


CTE can improve the performance by not always



PostgreSQL
===========

before version 12

select  * from orders where order_id = 10000;

with orders_cte as 
(
select * from orders
)
select * from orders_cte where order_id = 10000;

on CTE the indexes are not performant

before version 12 in postgreSQL
Common table expression (CTE)
==============================

this is to simplify the complex queries.

it improves the readability of a query

Orders table
=============

order_id, order_data, order_customer_id, order_status

total orders each customer has placed

I want to find out premium customers (who places more orders)


average number of numbers placed by each customer

Solution 1 (subquery)
======================

select avg(total_orders_per_customer) as avg_orders_per_customer from (
select order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id) x


Solution 2 (CTE/WITH CLAUSE)
============================

WITH total_orders (order_customer_id,total_orders_per_customer) as
(select order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id)

select avg(total_orders_per_customer) as avg_orders_per_customer from total_orders

subquery
==========
query3(query2(query1))

CTE
====
query1

query2

query3


I want to find premium customers who places more orders than the average number of orders
===================

select * from (select order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id) total_orders join(select avg(total_orders_per_customer) as avg_orders_per_customer from (
select order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id) x) average_orders on total_orders.total_orders_per_customer > average_orders.avg_orders_per_customer


3 step process
===============
1. calculate total orders per customer
2. calculate average number of number orders for the customers
3. get to know the customers who are premium

WITH total_orders(order_customer_id, total_orders_per_customer) as
(select order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id),
average_orders(avg_orders_per_customer) as
(select avg(total_orders_per_customer) as avg_orders_per_customer from total_orders)
select * from orders;
select * from total_orders join average_orders on total_orders.total_orders_per_customer  >  average_orders.avg_orders_per_customer;


CTE defines a temporary resultset that you can refer in select, insert, update, delete statements immedicate follows the CTE



WITH total_orders(order_customer_id, order_customer_id1, total_orders_per_customer) as
(select order_customer_id, order_customer_id, count(*) as total_orders_per_customer from orders group by order_customer_id),
average_orders(avg_orders_per_customer) as
(select avg(total_orders_per_customer) as avg_orders_per_customer from total_orders)
select * from total_orders join average_orders on total_orders.total_orders_per_customer  >  average_orders.avg_orders_per_customer;


====================


CTE can improve the performance by not always



PostgreSQL
===========

before version 12

select  * from orders where order_id = 10000;

with orders_cte as 
(
select * from orders
)
select * from orders_cte where order_id = 10000;

on CTE the indexes are not performant

before version 12 in postgreSQL
=================================================================================================================================================
***AZURE DATABRICKS***

dbutils.help()

credentials: DatabricksCredentialUtils -> Utilities for interacting with credentials within notebooks
data: DataUtils -> Utilities for understanding and interacting with datasets (EXPERIMENTAL)
fs: DbfsUtils -> Manipulates the Databricks filesystem (DBFS) from the console
jobs: JobsUtils -> Utilities for leveraging jobs features
library: LibraryUtils -> Utilities for session isolated libraries
meta: MetaUtils -> Methods to hook into the compiler (EXPERIMENTAL)
notebook: NotebookUtils -> Utilities for the control flow of a notebook (EXPERIMENTAL)
preview: Preview -> Utilities under preview category
secrets: SecretUtils -> Provides utilities for leveraging secrets within notebooks
widgets: WidgetsUtils -> Methods to create and get bound value of input widgets inside notebooks
##########################################################################################################3##
##dbutils.fs.help()####

mount
mount(source: String, mountPoint: String, encryptionType: String = "", owner: String = null, extraConfigs: Map = Map.empty[String, String]): boolean -> Mounts the given source directory into DBFS at the given mount point
mounts: Seq -> Displays information about what is mounted within DBFS
refreshMounts: boolean -> Forces all machines in this cluster to refresh their mount cache, ensuring they receive the most recent information
unmount(mountPoint: String): boolean -> Deletes a DBFS mount point
updateMount(source: String, mountPoint: String, encryptionType: String = "", owner: String = null, extraConfigs: Map = Map.empty[String, String]): boolean -> Similar to mount(), but updates an existing mount point (if present) instead of creating a new one

fsutils
cp(from: String, to: String, recurse: boolean = false): boolean -> Copies a file or directory, possibly across FileSystems
head(file: String, maxBytes: int = 65536): String -> Returns up to the first 'maxBytes' bytes of the given file as a String encoded in UTF-8
ls(dir: String): Seq -> Lists the contents of a directory
mkdirs(dir: String): boolean -> Creates the given directory if it does not exist, also creating any necessary parent directories
mv(from: String, to: String, recurse: boolean = false): boolean -> Moves a file or directory, possibly across FileSystems
put(file: String, contents: String, overwrite: boolean = false): boolean -> Writes the given String out to a file, encoded in UTF-8
rm(dir: String, recurse: boolean = false): boolean -> Removes a file or directory